@page "/grilles"
@inject LotteryApiClient LotteryApiClient
@inject ILogger<GenerateGrids> Logger
@inject IJSRuntime Js

<PageTitle>Générer des grilles</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="page-container">
    <MudPaper Elevation="1" Class="section-panel">
        <MudText Typo="Typo.h4" GutterBottom="true">Générer des grilles</MudText>
        <MudText Typo="Typo.body2">
            Les grilles sont générées à partir de statistiques observées (fréquence/récence).
            Chaque combinaison reste équiprobable théoriquement.
        </MudText>

        <MudGrid Class="mt-4">
            <MudItem xs="12" md="4">
                <MudSelect T="string" Label="Jeu" Variant="Variant.Outlined" @bind-Value="_selectedGame">
                    <MudSelectItem T="string" Value="@("Loto")">Loto</MudSelectItem>
                    <MudSelectItem T="string" Value="@("EuroMillions")">EuroMillions</MudSelectItem>
                </MudSelect>
            </MudItem>
            <MudItem xs="12" md="4">
                <MudNumericField T="int"
                                 Label="Nombre de grilles"
                                 Variant="Variant.Outlined"
                                 Min="1"
                                 Max="100"
                                 Immediate="true"
                                 @bind-Value="_requestedGridCount" />
            </MudItem>
            <MudItem xs="12" md="4">
                <MudSelect T="string" Label="Stratégie" Variant="Variant.Outlined" @bind-Value="_selectedStrategy">
                    <MudSelectItem T="string" Value="@("uniform")">A) Aléatoire (uniforme)</MudSelectItem>
                    <MudSelectItem T="string" Value="@("frequency")">B) Pondéré par fréquence globale</MudSelectItem>
                    <MudSelectItem T="string" Value="@("recency")">C) Pondéré par récence (exp)</MudSelectItem>
                </MudSelect>
            </MudItem>
        </MudGrid>

        <MudPaper Elevation="0" Class="strategy-help-card">
            <MudText Typo="Typo.subtitle2">Comprendre les stratégies proposées</MudText>
            <ul class="strategy-help-list">
                <li><strong>A) Aléatoire (uniforme)</strong> : tous les numéros ont le même poids.</li>
                <li><strong>B) Pondéré par fréquence globale</strong> : les numéros les plus fréquents sont davantage pondérés.</li>
                <li><strong>C) Pondéré par récence</strong> : les tirages récents pèsent plus que les anciens.</li>
            </ul>
            <MudText Typo="Typo.caption">
                Les pondérations sont informatives : elles ne changent pas l'équiprobabilité théorique des combinaisons.
            </MudText>
        </MudPaper>

        <MudSlider T="int"
                   Class="mt-3"
                   Min="1"
                   Max="100"
                   Step="1"
                   ValueLabel="true"
                   Color="Color.Primary"
                   @bind-Value="_requestedGridCount" />

        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mt-2 wrap-stack">
            <MudSwitch T="bool"
                       @bind-Value="_enableDrawAnimation"
                       Color="Color.Info"
                       Label="Animation de tirage" />
            <MudText Typo="Typo.caption">
                Désactivez cette option pour obtenir uniquement les chiffres, sans animation.
            </MudText>
        </MudStack>

        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   Disabled="@_isLoading"
                   OnClick="@GenerateAsync"
                   Class="mt-3">
            @if (_isLoading)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-2" />
            }
            Générer
        </MudButton>
    </MudPaper>

    @if (!string.IsNullOrWhiteSpace(_errorMessage))
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Dense="true" Class="mt-4">
            @_errorMessage
        </MudAlert>
    }

    @if (_showDrawAnimation)
    {
        <MudPaper Elevation="1" Class="draw-sim-card mt-4">
            <MudText Typo="Typo.h6">Tirage en cours...</MudText>
            <MudText Typo="Typo.caption">
                Simulation visuelle (@_animatingGame). Le résultat arrive juste après.
            </MudText>

            <div class="draw-machine mt-3">
                <div class="draw-machine-glow"></div>
                <div class="ball-row ball-row-main">
                    @foreach (var number in _animationMainNumbers)
                    {
                        <span class="number-ball number-ball-main number-ball-animated">@number</span>
                    }
                </div>

                <div class="ball-row ball-row-bonus mt-2">
                    @foreach (var number in _animationBonusNumbers)
                    {
                        <span class="number-ball number-ball-bonus number-ball-animated">@number</span>
                    }
                </div>
            </div>
        </MudPaper>
    }

    @if (_result is not null)
    {
        <MudPaper Elevation="0" Class="mt-4 disclaimer-panel">
            <MudText Typo="Typo.body2">@_result.Disclaimer</MudText>
            <MudText Typo="Typo.caption">
                Généré le @FormatDateTime(_result.GeneratedAt) | Stratégie : @GetStrategyLabel(_result.Strategy)
                | Combinaisons possibles : @_result.TotalCombinations.ToString("N0")
            </MudText>
        </MudPaper>

        @if (!string.IsNullOrWhiteSpace(_result.Warning))
        {
            <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Dense="true" Class="mt-3">
                @_result.Warning
            </MudAlert>
        }

        <MudGrid Class="mt-2">
            @foreach (var entry in _result.Grids.Select((grid, index) => new { Grid = grid, Index = index + 1 }))
            {
                <MudItem xs="12" md="6" lg="4">
                    <MudPaper Elevation="1" Class="grid-card">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                            <MudText Typo="Typo.subtitle2">Grille #@entry.Index</MudText>
                            <MudChip T="string" Color="Color.Info" Variant="Variant.Outlined" Size="Size.Small">
                                Score @entry.Grid.Score.ToString("0.00")/100
                            </MudChip>
                        </MudStack>

                        <MudText Typo="Typo.caption" Class="mt-2">Numéros principaux</MudText>
                        <div class="ball-row ball-row-main mt-1">
                            @foreach (var number in entry.Grid.MainNumbers.OrderBy(value => value))
                            {
                                <span class="number-ball number-ball-main">@number</span>
                            }
                        </div>

                        <MudText Typo="Typo.caption" Class="mt-2">Bonus</MudText>
                        <div class="ball-row ball-row-bonus mt-1">
                            @foreach (var number in entry.Grid.BonusNumbers.OrderBy(value => value))
                            {
                                <span class="number-ball number-ball-bonus">@number</span>
                            }
                        </div>

                        <MudText Typo="Typo.caption" Class="mt-3">
                            Top numéros (pondération) : M[@string.Join(", ", entry.Grid.TopMainNumbers)] B[@string.Join(", ", entry.Grid.TopBonusNumbers)]
                        </MudText>

                        <MudButton Variant="Variant.Text" Color="Color.Primary" Size="Size.Small" OnClick="@(() => CopyGridAsync(entry.Grid))" Class="mt-1">
                            Copier
                        </MudButton>
                    </MudPaper>
                </MudItem>
            }
        </MudGrid>
    }
</MudContainer>

@code {
    private string _selectedGame = "Loto";
    private int _requestedGridCount = 5;
    private string _selectedStrategy = "uniform";
    private bool _enableDrawAnimation = true;
    private bool _isLoading;
    private bool _showDrawAnimation;
    private string? _errorMessage;
    private string _animatingGame = "Loto";
    private IReadOnlyList<int> _animationMainNumbers = [];
    private IReadOnlyList<int> _animationBonusNumbers = [];
    private ApiGenerateGridsResponse? _result;

    private async Task GenerateAsync()
    {
        _isLoading = true;
        _errorMessage = null;
        _result = null;
        _showDrawAnimation = false;
        _animatingGame = _selectedGame;

        try
        {
            var request = new ApiGenerateGridsRequest
            {
                Game = _selectedGame,
                Count = Math.Clamp(_requestedGridCount, 1, 100),
                Strategy = _selectedStrategy
            };

            var generated = await LotteryApiClient.GenerateGridsAsync(request, CancellationToken.None);
            if (generated is null)
            {
                _errorMessage = "Génération indisponible. Vérifiez la connectivité API.";
                return;
            }

            if (_enableDrawAnimation)
            {
                await RunDrawAnimationAsync(_selectedGame, generated);
            }

            _result = generated;
        }
        catch (Exception exception)
        {
            Logger.LogError(exception, "Erreur de génération de grilles.");
            _errorMessage = "Erreur inattendue lors de la génération.";
        }
        finally
        {
            _isLoading = false;
            _showDrawAnimation = false;
        }
    }

    private async Task CopyGridAsync(ApiGeneratedGridResponse grid)
    {
        var text = $"Principaux : {string.Join("-", grid.MainNumbers)} | Bonus : {string.Join("-", grid.BonusNumbers)} | Score : {grid.Score:0.00}/100";
        await Js.InvokeVoidAsync("navigator.clipboard.writeText", text);
    }

    private static string FormatDateTime(DateTimeOffset value) => value.ToLocalTime().ToString("dd/MM/yyyy HH:mm:ss");

    private static string GetStrategyLabel(string strategy) =>
        strategy switch
        {
            "uniform" => "A) Aléatoire (uniforme)",
            "frequency" => "B) Pondéré par fréquence globale",
            "recency" => "C) Pondéré par récence",
            _ => strategy
        };

    private async Task RunDrawAnimationAsync(string game, ApiGenerateGridsResponse generated)
    {
        var firstGrid = generated.Grids.FirstOrDefault();
        if (firstGrid is null)
        {
            return;
        }

        _showDrawAnimation = true;
        var (mainMax, bonusMax, bonusCount) = GetBallRanges(game);

        for (var index = 0; index < 24; index++)
        {
            _animationMainNumbers = BuildUniqueSortedNumbers(5, mainMax);
            _animationBonusNumbers = BuildUniqueSortedNumbers(bonusCount, bonusMax);
            await InvokeAsync(StateHasChanged);
            await Task.Delay(index < 18 ? 75 : 110);
        }

        _animationMainNumbers = firstGrid.MainNumbers.OrderBy(value => value).ToArray();
        _animationBonusNumbers = firstGrid.BonusNumbers.OrderBy(value => value).ToArray();
        await InvokeAsync(StateHasChanged);
        await Task.Delay(500);
    }

    private static (int MainMax, int BonusMax, int BonusCount) GetBallRanges(string game) =>
        game.Equals("EuroMillions", StringComparison.OrdinalIgnoreCase)
            ? (50, 12, 2)
            : (49, 10, 1);

    private static IReadOnlyList<int> BuildUniqueSortedNumbers(int count, int maxValue)
    {
        var values = new HashSet<int>();
        while (values.Count < count)
        {
            values.Add(Random.Shared.Next(1, maxValue + 1));
        }

        return values.OrderBy(value => value).ToArray();
    }
}
